import static TCDModUtils.getMixinFileNames;

plugins { id 'com.github.johnrengelman.shadow' }

architectury
{
	platformSetupLoomIde()
	neoForge()
}

configurations
{
	common { canBeResolved = true; canBeConsumed = false }

	compileClasspath.extendsFrom common
	runtimeClasspath.extendsFrom common
	developmentNeoForge.extendsFrom common

	// Files in this configuration will be bundled into your mod using the Shadow plugin.
	// Don't use the `shadow` configuration from the plugin itself as it's meant for excluding files.
	shadowBundle { canBeResolved = true; canBeConsumed = false }
}

repositories
{
	maven { name = 'NeoForged'; url = 'https://maven.neoforged.net/releases' }
}

dependencies
{
	neoForge "net.neoforged:neoforge:${parent["neoforge.version"]}"
	modImplementation "dev.architectury:architectury-neoforge:${parent["architectury.version"]}"

	common(project(path: ':common', configuration: 'namedElements')) { transitive false }
	shadowBundle project(path: ':common', configuration: 'transformProductionNeoForge')
}

processResources
{
	//obtain array of applicable mixin files, and turn it into string
	String mixins = (getMixinFileNames(project) + getMixinFileNames(project(":common")))
		.collect { '[[mixins]]\nconfig = "' + it + '"\n' }
		.join('\n')

	//expand root project properties to the 'neoforge.mods.toml' file
	filesMatching(["META-INF/neoforge.mods.toml", "*.json"]) {
		expand(properties: [mixins: mixins] + parent.properties)
	}
}

shadowJar
{
	configurations = [project.configurations.shadowBundle]
	archiveClassifier = 'dev-shadow'
}

remapJar { inputFile.set shadowJar.archiveFile }
